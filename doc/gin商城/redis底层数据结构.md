### redis底层数据结构

#### SDS结构设计

- 出现原因？

  > 为了解决C语言字符串的缺点，比如‘\0’问题，缓冲区溢出问题，二进制安全问题，内存浪费问题。

- 实现内容？

  > 1. 使用单独的len来统计字符长度
  > 2. alloc函数实现空间内存的分配
  > 3. flags用来标记sds的数据类型
  > 4. buf[]用来存储字符串

- 解决的问题？

  > 1. 字符串长度的统计实现到了O(1)
  > 2. 使用\_attribute\_((packed))可以取消编译器在编译过程中的自动对齐
  > 3. 使用alloc-len可以对缓存空间进行计算，当不足时，并且存储小于1MB时进行翻倍扩容，否则时直接增加1MB
  > 4. buf[]函数解决了二进制安全问题，能够更好的存储\0类字符

#### 链表

优点：增加了节点复制函数：`void *(*dup)(void *ptr)`;，节点释放函数`void *(*free)(void *ptr)`;，节点比较函数`void *(*match)(void *ptr)`;，链表节点数量`unsigned long len;`

缺点：链表使用内存不连续，无法很好利用cpu缓存，保存节点需要链表节点结构头的分配，内存开销较大。

#### 压缩列表

优点：使用连续的内存空间，使用prevlen和encoding两个函数，能实现根据不同数据类型来调整内存空间，从而实现节省内存。

缺点：设计缺陷使得当会发生连锁更新问题。当插入的值长度大于等于254会需要调整后续的空间

#### 哈希表

使用链式哈希来解决哈希冲突，当哈希冲突达到一定程度时进行rehash操作

#### 整数集合

`contents`数组按照encoding调整数据类型，只支持升级，也就是扩容，不支持降级，目的时为了节省内存资源

#### 跳表

优点：能实现高效的搜索，时间复杂度为O(logN),跳表节点查询过程为当权重不够时向后，不然向前进行查询，跳表层数设置为random，小于0.25则加一层。