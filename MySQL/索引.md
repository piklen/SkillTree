### 索引

#### 什么是MySQL的索引？

索引是一种用于提高MySQL查询性能的数据结构，利用索引可以不必进行全表扫描，减少查询的时间，加速数据索引的时间，从而提高了MySQL的查询效率。常见的索引有：唯一索引、主键索引、普通索引、联合索引。但是创建索引也会消费一定的空间，所以在创建索引时应当综合进行考虑。

#### 常见的索引分类有哪些？

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

![索引分类.drawio](https://hruoxuan.oss-cn-shenzhen.aliyuncs.com/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png)

#### InnoDB怎么进行索引的选择？

- 如果存在主键，哪主键就会是聚簇索引的主键。
- 如果没有主键，哪就会把第一列唯一非空的哪个列作为聚簇索引的主键。
- 如果主键和唯一非空列都没有，哪InnoDB会使用row_id列生成一个隐形的自增id列，作为聚簇索引的主键。

#### 数据存储在 B+Tree 索引时是长什么样子的？

![img](https://hruoxuan.oss-cn-shenzhen.aliyuncs.com/1706598055147-f7fc7c72-f529-41d7-af23-2c3018b90bd1.png)

- 只有叶子节点存储数据
- 叶子节点是顺序排列的
- 非叶子节点存储的是区间
- 叶子节点之间用双向链表连接

#### MySQL使用B+树后的查询流程是什么样子的？

比如说查询$id=15$,依据上图。

- $15<28$所以先找到$p1$
- $10<15<17$找到$p2$
- 然后在磁块5中找到$15$，进行返回

#### 覆盖索引是什么?

覆盖索引指的是所要查询的内容全部存在与索引中，不再进行回表操作的一种索引。

#### 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？

1. $B+Tree$ $vs$ $BTree$

- B树由于非叶子节点也要进行存储数据，导致其在进行增删数据的时候有可能会进行复杂的变化
- B+树叶子节点之间是双向链表连接的，更适合基于顺序的范围查找

2. B+ 树与二叉树的对比

- 时间复杂度为$O(log_2N)$,磁盘所需的O/I操作要多的多

#### 常见索引的创建方式有哪几种？

##### 主键索引

```mysql
CREATE TABLE test(
    id int,
    name VARCHAR(4),
    PRIMARY KEY (id)
);
```

##### 唯一索引

在创建表时，创建唯一索引的方式如下：

```sql
CREATE TABLE test  (
  id int,
  name VARCHAR(4),
  UNIQUE KEY(id) 
);
```

建表后，如果要创建唯一索引，可以使用这面这条命令：

```sql
CREATE UNIQUE INDEX index_id
ON test (id); 
```

##### 普通索引

在创建表时，创建普通索引的方式如下：

```sql
CREATE TABLE test  (
  id int,
  name VARCHAR(4),
  INDEX(id) 
);
```

建表后，如果要创建普通索引，可以使用这面这条命令：

```sql
CREATE INDEX index_id
ON test(id); 
```

##### 前缀索引

在创建表时，创建前缀索引的方式如下：

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```

建表后，如果要创建前缀索引，可以使用这面这条命令：

```sql
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

##### 联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。

```sql
CREATE INDEX index_id_name ON product(id, name);
```

#### 什么是最左匹配原则？

在联合索引中，优先走最左边列的索引。 对于多个字段的联合索引，也同理。 如index(a,b,c) 联合索引，则相当于创建了a 单列索引，(a,b)联合索引，和(a,b,c)联合索引。因为最左匹配原则的存在有可能导致索引失效。比如说范围查询（>、<）、以及只查询c或者b、c。对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。

#### 什么是索引下推？

索引下推是发生在需要整表扫描的情况下，适用于InnoDB和MyISAM引擎。不适用与子条件查询以及出发条件等情况的一种减少回表操作的优化方式。

> 索引下推（Index Pushdown）是指数据库系统在执行查询时，尝试将部分查询操作下推（推送）到数据存储引擎的索引层进行处理，以减少从存储中检索数据的数据量，从而提高查询性能的技术。
>
> 在关系型数据库中，索引通常用于加快数据检索的速度。传统上，当执行查询时，数据库系统会先从存储引擎中获取数据，然后再应用查询条件进行过滤和排序。而索引下推则尝试在存储引擎层面上对查询条件进行处理，以减少从存储引擎中检索数据的数量。

##### 不使用索引条件下推优化时的查询过程

> 获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。然后通过where条件判断当前数据是否符合条件，符合返回数据。

##### 使用索引条件下推优化时的查询过程

> 获取下一行的索引信息。检查索引中存储的列信息是否符合索引条件，如果符合将整行数据读取出来，如果不符合跳过读取下一行。用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。

#### 索引的优点是什么？缺点是什么？什么时候适合创建索引？什么时候不需要索引？

##### 索引的优点有：

- 加快数据检索的速度
- 索引是有序的，所以使用索引可以加快数据的排序
- 索引可以加速表连接

##### 索引的缺点有：

- 占用存储空间
- 创建索引和维护索引需要耗费时间，对表进行增删改时索引需要维护

##### 什么时候适用索引?

- 字段的区分度高，或者字段有唯一性时
- 经常使用`where`查询时，以及经常使用`GROUP BY`、`ORDER BY`等排序语句

##### 什么时候不需要索引？

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段
- 字段存在大量重复字段，区分度不高，不如性别
- 表数据很少时，一般不需要创建索引
- 经常更新的字段一般不使用索引

#### 索引优化的方法有哪些？

- 前缀索引优化：使用前缀索引可以帮助我们减小索引项的大小。
- 覆盖索引优化：使用覆盖所有可以避免一定的回表操作，减少系统I/O。
- 主键索引设置为自增加：这样追加数据就会添加到最后尾，同时页减少了页分裂。
- 索引列最好设置为NOT NULL：可以减少优化器逻辑判断，也可以减少空间。

#### 引发索引失效的情况有哪些？

- 使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 在查询条件中对索引列做了计算、函数、类型转换操作（索引是字符串，输入是整数会失效。索引是整型，输入是字符串不会失效），这些情况下都会造成索引失效；MySQL8.0增加了函数索引，`alter table t_user add key idx_name_length ((length(name)));`
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

#### 常见的扫描类型执行效率有哪些？

- All（全表扫描）；
- index（全索引扫描）；
- range（索引范围扫描）；
- ref（非唯一索引扫描）；
- eq_ref（唯一索引扫描）；
- const（结果只有一条的主键或唯一索引扫描）。

#### count(*) 和 count(1) 有什么区别？哪个性能最好？

`count(*)` 是统计表中所有的记录数，包括了所有的列，即使这些列的值是 NULL。

`count(1)` 也是统计表中所有的记录数，但它只考虑值为1的列，忽略其他列。

$count(*)=count(1)>count(主键字段)>count(字段)$

#### 如何优化count(*)？

- 使用近似值：使用 show table status 或者 explain 命令来表进行估算。explain中的`rows`字段近似说明了行数。
- 额外表保存计数值，新建一个表来专门对这个字段数量进行统计。当插入一条数据时字段数量进行+1，同时删除时减少1。

#### 参考资料

> [索引常见面试题](https://xiaolincoding.com/mysql/index/index_interview.html)